<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ガチIQ（MVP）- 3×3マトリクス自動生成</title>
<style>
  :root{
    --bg0:#07090c;
    --bg1:#0b0f14;

    --stroke: rgba(255,255,255,0.10);
    --text:#e9eef6;
    --muted: rgba(233,238,246,0.66);

    --neon:#34f3a0;
    --neon2:#18c57d;
    --danger:#ff4d6d;

    --line:#2a2a2a;
  }

  *{box-sizing:border-box}
  body{
    margin:0;
    background:
      radial-gradient(1200px 600px at 20% 0%, rgba(52,243,160,0.10), transparent 60%),
      radial-gradient(900px 600px at 90% 20%, rgba(52,243,160,0.06), transparent 65%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
    color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }

  .wrap{
    max-width: 820px;
    margin: 0 auto;
    padding: 18px 14px 26px;
  }
  .topbar{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:12px;
    margin-bottom: 12px;
  }
  h1{
    margin:0;
    font-size: 18px;
    letter-spacing: .08em;
    font-weight: 800;
  }
  .pill{
    padding:8px 10px;
    border:1px solid var(--stroke);
    background: rgba(255,255,255,0.03);
    border-radius: 12px;
    font-size: 12px;
    color: var(--muted);
    white-space:nowrap;
    height: fit-content;
  }

  .card{
    position:relative; /* ← キャラHUD用 */
    border:1px solid var(--stroke);
    background: rgba(255,255,255,0.04);
    border-radius: 16px;
    padding: 14px;
    box-shadow:
      0 10px 30px rgba(0,0,0,0.35),
      0 0 0 1px rgba(52,243,160,0.06) inset;
    backdrop-filter: blur(6px);
  }

  .matrix{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-top: 6px;
  }

  .cell{
    border:1px solid rgba(255,255,255,0.10);
    background: #fff;
    border-radius: 14px;
    overflow:hidden;
    aspect-ratio: 1 / 1;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  .cell.q{
    background: #fff;
    position:relative;
  }
  .qmark{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    font-size: 34px;
    color:#111;
    letter-spacing:.05em;
  }

  .msg{
    margin-top: 12px;
    padding: 10px 12px;
    border-radius: 12px;
    border:1px solid rgba(255,255,255,0.10);
    background: rgba(255,255,255,0.03);
    color: var(--muted);
    font-size: 13px;
    line-height: 1.45;
    min-height: 42px;
    text-align:center;
  }
  .msg.ok{
    border-color: rgba(52,243,160,0.30);
    background: rgba(52,243,160,0.10);
    color: #d7fff0;
  }
  .msg.ng{
    border-color: rgba(255,77,109,0.30);
    background: rgba(255,77,109,0.10);
    color: #ffe1e1;
  }

  .opts{
    display:grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap:10px;
    width:100%;
    max-width:360px;
    margin:12px auto 0;
  }
  .opt{
    border: 1px solid rgba(255,255,255,0.10);
    background: rgba(255,255,255,0.04);
    box-shadow: 0 8px 18px rgba(0,0,0,0.28);
    border-radius: 14px;
    padding: 8px;
    cursor:pointer;
    transition: transform .06s ease;
    display:flex;
    gap:8px;
    align-items:center;
    justify-content:flex-start;
    min-height: 72px;
    width:100px;
  }
  .opt:hover{
    border-color: rgba(52,243,160,0.28);
    background: rgba(255,255,255,0.06);
  }
  .opt:active{ transform: translateY(1px); }
  .badge{
    width: 26px;
    height: 26px;
    border-radius: 9px;
    display:flex;
    align-items:center;
    justify-content:center;
    border:1px solid rgba(52,243,160,0.35);
    color: rgba(52,243,160,0.95);
    background: rgba(0,0,0,0.18);
    font-weight: 900;
    flex: 0 0 auto;
    box-shadow: 0 0 18px rgba(52,243,160,0.10);
  }
  .thumb{
    width: 56px;
    height: 56px;
    border-radius: 12px;
    overflow:hidden;
    border:1px solid rgba(255,255,255,0.12);
    background:#fff;
    flex: 0 0 auto;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  .row{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
    justify-content:space-between;
    margin-top: 12px;
  }

  .btn{
    border: 1px solid rgba(52,243,160,0.22);
    background: linear-gradient(180deg, rgba(52,243,160,0.18), rgba(52,243,160,0.06));
    color: var(--text);
    padding: 10px 12px;
    border-radius: 12px;
    cursor:pointer;
    font-weight: 700;
    letter-spacing:.04em;
    box-shadow:
      0 8px 20px rgba(0,0,0,0.35),
      0 0 0 1px rgba(52,243,160,0.10) inset;
  }
  .btn:active{ transform: translateY(1px); }
  .btn.secondary{
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.06);
    color: rgba(233,238,246,0.85);
  }

  details{
    margin-top: 12px;
    border:1px solid rgba(255,255,255,0.10);
    border-radius: 12px;
    padding: 10px 12px;
    background: rgba(255,255,255,0.03);
  }
  details > summary{
    cursor:pointer;
    font-weight: 800;
    color: rgba(233,238,246,0.80);
  }
  .small{
    color: var(--muted);
    font-size: 12px;
    line-height: 1.5;
    margin-top: 8px;
    white-space: pre-wrap;
  }

  /* ===== C案：余地ゼロでキャラを重ねるHUD ===== */
  .charaHud{
    position:absolute;
    right:12px;
    top:12px;
    display:flex;
    align-items:flex-end;
    gap:10px;
    pointer-events:none;
    z-index:5;
  }
  .charaImg{
    width:64px;
    height:64px;
    object-fit:contain;
    filter: drop-shadow(0 8px 18px rgba(0,0,0,.45));
    opacity:.95;
  }
  .charaBubble{
    max-width: 220px;
    padding:8px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.14);
    background: rgba(0,0,0,0.35);
    color: rgba(233,238,246,0.92);
    font-size:12px;
    line-height:1.35;
    backdrop-filter: blur(6px);
  }
</style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>ガチIQ（MVP）</h1>
      </div>
      <div class="pill" id="statusPill">出題準備中…</div>
    </div>

    <div class="card">

      <!-- C：キャラHUD（余地不要で重ねる） -->
      <div class="charaHud" id="charaHud" style="display:none" aria-hidden="true">
        <img class="charaImg" id="charaImg" src="chara/chi.png" alt="">
        <div class="charaBubble" id="charaBubble">…</div>
      </div>

      <div class="matrix" id="matrix"></div>

      <div class="msg" id="msg">「次の問題」を押してスタート。</div>

      <div class="opts" id="opts"></div>

      <div class="row">
        <button class="btn" id="newBtn">次の問題</button>
        <button class="btn secondary" id="showBtn">正解を表示</button>
      </div>

      <details>
        <summary>（開発用）今回の生成ルールを見る</summary>
        <div class="small" id="debug"></div>
      </details>
    </div>
  </div>

<script>
(() => {
  // ========= Utilities =========
  const deepEq = (a,b) => a.length===b.length && a.every((v,i)=>v===b[i]);
  const rndInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
  const shuffle = (arr) => {
    const a = arr.slice();
    for (let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  };
  const countOnes = (c) => c.reduce((s,v)=>s+(v?1:0),0);
  const cellKey = (c) => c.join("");

  // ========= Cell ops (3×3 as flat 9 bits) =========
  function rot90(c){
    return [
      c[6],c[3],c[0],
      c[7],c[4],c[1],
      c[8],c[5],c[2],
    ];
  }
  function rot180(c){ return rot90(rot90(c)); }

  function shiftRight(c){
    return [
      c[2],c[0],c[1],
      c[5],c[3],c[4],
      c[8],c[6],c[7],
    ];
  }
  function shiftDown(c){
    return [
      c[6],c[7],c[8],
      c[0],c[1],c[2],
      c[3],c[4],c[5],
    ];
  }

  function xor(a,b){ return a.map((v,i)=> (v ^ b[i]) ); }

  function flipH(c){
    return [
      c[2],c[1],c[0],
      c[5],c[4],c[3],
      c[8],c[7],c[6],
    ];
  }
  function flipV(c){
    return [
      c[6],c[7],c[8],
      c[3],c[4],c[5],
      c[0],c[1],c[2],
    ];
  }

  function swap2(c){
    const a = c.slice();
    const i = rndInt(0,8);
    let j = rndInt(0,8);
    if (j===i) j = (j+1)%9;
    [a[i],a[j]] = [a[j],a[i]];
    return a;
  }
  function toggleK(c, k=1){
    const a = c.slice();
    const idx = shuffle([...Array(9)].map((_,i)=>i)).slice(0, k);
    idx.forEach(i => a[i] = a[i] ? 0 : 1);
    return a;
  }

  // ========= Random base cell generation =========
  function randCell(){
    const k = rndInt(2,4);
    const positions = shuffle([...Array(9)].map((_,i)=>i)).slice(0,k);
    const c = Array(9).fill(0);
    positions.forEach(i => c[i]=1);
    return c;
  }

  // ========= Rule templates =========
  const ROW_RULES = [
    {
      name: "右 = 左 XOR 中央",
      buildRow: (L, M) => {
        const R = xor(L, M);
        return { L, M, R };
      }
    },
  ];

  // ========= SVG render（黒マスの見た目だけ 4種：solid/hatch/gray/mix） =========
  function cellToSVG(c, size=96, blackMode="solid"){
    const s = size/3;

    const defs = `
      <defs>
        <pattern id="hatch" patternUnits="userSpaceOnUse" width="10" height="10" patternTransform="rotate(45)">
          <line x1="0" y1="0" x2="0" y2="10" stroke="#000" stroke-width="3" />
        </pattern>
      </defs>
    `;

    const fillFor = (i) => {
      if (blackMode === "solid") return "#000";
      if (blackMode === "gray")  return "#666";
      if (blackMode === "hatch") return "url(#hatch)";
      if (blackMode === "mix"){
        const m = i % 3;
        return (m===0) ? "#000" : (m===1) ? "url(#hatch)" : "#666";
      }
      return "#000";
    };

    let rects = "";
    for(let i=0;i<9;i++){
      if(c[i]){
        const x = (i%3)*s, y = Math.floor(i/3)*s;
        rects += `<rect x="${x}" y="${y}" width="${s}" height="${s}" fill="${fillFor(i)}"/>`;
      }
    }

    const grid = `
      <path d="
        M ${s} 0 V ${size}
        M ${2*s} 0 V ${size}
        M 0 ${s} H ${size}
        M 0 ${2*s} H ${size}
      " stroke="rgba(0,0,0,0.18)" stroke-width="2" />
    `;

    return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" aria-hidden="true">
      ${defs}
      <rect width="${size}" height="${size}" fill="#fff" stroke="rgba(0,0,0,0.35)" stroke-width="2"/>
      ${rects}
      ${grid}
    </svg>`;
  }

  // ========= Build options (6 choices) =========
  function buildOptions(answer){
    const candidates = [];
    const add = (c) => {
      const k = cellKey(c);
      if (!candidates.some(x => cellKey(x)===k)) candidates.push(c);
    };

    add(answer);
    add(rot90(answer));
    add(rot180(answer));
    add(flipH(answer));
    add(flipV(answer));
    add(shiftRight(answer));
    add(shiftDown(answer));
    add(xor(answer, rot90(answer)));
    add(toggleK(answer,1));
    add(toggleK(answer,2));
    add(swap2(answer));

    const filtered = candidates.filter(c => {
      const ones = countOnes(c);
      return ones >= 1 && ones <= 8;
    });

    const distractPool = filtered.filter(c => !deepEq(c, answer));
    const distractors = shuffle(distractPool).slice(0, 5);

    let tries = 0;
    while (distractors.length < 5 && tries < 60){
      tries++;
      const variant = toggleK(answer, rndInt(1,2));
      if (!deepEq(variant, answer) && !distractors.some(d => deepEq(d, variant))){
        const ones = countOnes(variant);
        if (ones >= 1 && ones <= 8) distractors.push(variant);
      }
    }

    const options = shuffle([answer, ...distractors]).slice(0,6);
    const ansIndex = options.findIndex(o => deepEq(o, answer));
    return { options, ansIndex };
  }

  function isRowRuleSatisfied(grid, rule) {
    for (let r = 0; r < 3; r++) {
      const L = grid[r][0], M = grid[r][1], R = grid[r][2];
      const expect = rule.buildRow(L, M).R;
      if (!deepEq(expect, R)) return false;
    }
    return true;
  }

  function isColRuleSatisfied(grid, rule) {
    for (let c = 0; c < 3; c++) {
      const L = grid[0][c], M = grid[1][c], R = grid[2][c];
      const expect = rule.buildRow(L, M).R;
      if (!deepEq(expect, R)) return false;
    }
    return true;
  }

  // ========= Generate 3×3 XOR (row+col satisfied) =========
  function generateQuestion(){
    const rule = ROW_RULES[0];

    function randCellWithDensity(){
      let c, guard = 0;
      while (guard++ < 200) {
        c = randCell();
        const ones = countOnes(c);
        if (ones >= 2 && ones <= 5) return c;
      }
      return randCell();
    }

    function makeSolvedGrid(){
      const a11 = randCellWithDensity();
      const a21 = randCellWithDensity();
      const a31 = xor(a11, a21);

      const a12 = randCellWithDensity();
      const a22 = randCellWithDensity();
      const a32 = xor(a12, a22);

      const a13 = xor(a11, a12);
      const a23 = xor(a21, a22);
      const a33 = xor(a31, a32);

      return [
        [a11, a12, a13],
        [a21, a22, a23],
        [a31, a32, a33],
      ];
    }

    let grid = null;
    for (let t=0; t<300; t++){
      const g = makeSolvedGrid();
      const all = g.flat();
      const onesList = all.map(countOnes);
      const tooExtreme = onesList.some(x => x <= 1 || x >= 8);
      const uniq = new Set(all.map(cellKey)).size;

      if (tooExtreme) continue;
      if (uniq < 7) continue;
      if (!isRowRuleSatisfied(g, rule)) continue;
      if (!isColRuleSatisfied(g, rule)) continue;

      grid = g;
      break;
    }
    if (!grid) grid = makeSolvedGrid();

    const answer = grid[2][2];
    const gridWithHole = [
      [grid[0][0], grid[0][1], grid[0][2]],
      [grid[1][0], grid[1][1], grid[1][2]],
      [grid[2][0], grid[2][1], null],
    ];

    const { options, ansIndex } = buildOptions(answer);

    const blackMode =
      (Math.random()<0.55) ? "solid" :
      (Math.random()<0.70) ? "hatch" :
      (Math.random()<0.85) ? "gray"  : "mix";

    const debugText =
`Type: 3x3
Rule: ${rule.name}
Mode: ${blackMode}
`;

    return {
      size: 3,
      blackMode,
      grid: gridWithHole,
      answer,
      options,
      ansIndex,
      debugText
    };
  }

  // ========= Generate 2×2 relation (rotate 90) =========
  function generateRelation2x2(){
    const ruleName = "A→B を 90°回転 / C→? も 90°回転";

    function randCellWithDensity(){
      let c, guard = 0;
      while (guard++ < 200) {
        c = randCell();
        const ones = countOnes(c);
        if (ones >= 2 && ones <= 5) return c;
      }
      return randCell();
    }

    const A = randCellWithDensity();
    const B = rot90(A);

    const C = randCellWithDensity();
    const answer = rot90(C);

    const grid = [
      [A, B],
      [C, null]
    ];

    const { options, ansIndex } = buildOptions(answer);

    const blackMode =
      (Math.random()<0.55) ? "solid" :
      (Math.random()<0.70) ? "hatch" :
      (Math.random()<0.85) ? "gray"  : "mix";

    const debugText =
`Type: 2x2
Rule: ${ruleName}
Mode: ${blackMode}
`;

    return {
      type: "relation2x2",
      size: 2,
      blackMode,
      grid,
      answer,
      options,
      ansIndex,
      debugText
    };
  }

  // ========= UI =========
  const $matrix = document.getElementById("matrix");
  const $opts = document.getElementById("opts");
  const $msg = document.getElementById("msg");
  const $debug = document.getElementById("debug");
  const $pill = document.getElementById("statusPill");
  const $newBtn = document.getElementById("newBtn");
  const $showBtn = document.getElementById("showBtn");

  // キャラHUD（C案）
  const $charaHud = document.getElementById("charaHud");
  const $charaImg = document.getElementById("charaImg");
  const $charaBubble = document.getElementById("charaBubble");

  const LABELS = ["A","B","C","D","E","F"];

  let state = {
    q: null,
    locked: false,
    revealed: false,
  };

  function setMessage(text, kind=""){
    $msg.classList.remove("ok","ng");
    if (kind) $msg.classList.add(kind);
    $msg.textContent = text;
  }

  function hideChara(){
    if ($charaHud) $charaHud.style.display = "none";
  }
  function sayChara(text, img){
    if (!$charaHud) return;
    $charaImg.src = img || "chara/chi.png";
    $charaBubble.textContent = text;
    $charaHud.style.display = "flex";
  }

  function renderMatrix(q){
    const n = q.size || 3;
    $matrix.innerHTML = "";
    $matrix.style.gridTemplateColumns = `repeat(${n}, 1fr)`;

    const holeIndex = n*n - 1;

    for (let i=0;i<n*n;i++){
      const cell = document.createElement("div");
      cell.className = "cell" + (i===holeIndex ? " q" : "");

      if (i===holeIndex){
        const mark = document.createElement("div");
        mark.className = "qmark";
        mark.textContent = "?";
        cell.appendChild(mark);
      } else {
        const r = Math.floor(i/n);
        const c = i % n;
        cell.innerHTML = cellToSVG(q.grid[r][c], 120, q.blackMode || "solid");
      }
      $matrix.appendChild(cell);
    }
  }

  function renderOptions(q){
    $opts.innerHTML = "";
    q.options.forEach((optCell, idx) => {
      const btn = document.createElement("button");
      btn.className = "opt";
      btn.type = "button";
      btn.addEventListener("click", () => onPick(idx));

      const badge = document.createElement("div");
      badge.className = "badge";
      badge.textContent = LABELS[idx];

      const thumb = document.createElement("div");
      thumb.className = "thumb";
      thumb.innerHTML = cellToSVG(optCell, 64, q.blackMode || "solid");

      btn.appendChild(badge);
      btn.appendChild(thumb);
      $opts.appendChild(btn);
    });
  }

  function updatePill(){
    if (!state.q){
      $pill.textContent = "未開始";
      return;
    }
    $pill.textContent = state.locked ? "回答済み" : "回答待ち";
  }

  function onPick(idx){
    if (!state.q || state.locked) return;
    state.locked = true;
    state.revealed = false;
    updatePill();

    const correct = (idx === state.q.ansIndex);
    if (correct){
      setMessage(`正解：${LABELS[idx]} ✅`, "ok");
      // C案：正解時
      sayChara("ギュウ。", "chara/chi.png");
    } else {
      setMessage(`不正解：${LABELS[idx]} ❌（正解はまだ隠しています）`, "ng");
      // C案：不正解時（デカブサ想定）
      sayChara("……", "chara/dekabusa.png");
    }
  }

  function showAnswer(){
    if (!state.q) return;
    state.revealed = true;
    const ansLabel = LABELS[state.q.ansIndex];
    setMessage(`正解：${ansLabel} ✅`, "ok");

    const qCells = Array.from($matrix.querySelectorAll(".cell"));
    const last = qCells[qCells.length - 1];
    last.innerHTML = cellToSVG(state.q.answer, 120, state.q.blackMode || "solid");
  }

  function newQuestion(){
    state.q = null;
    state.locked = false;
    state.revealed = false;

    let q = null;
    for (let t=0;t<30;t++){
      const pick = Math.random();
      q = (pick < 0.7) ? generateQuestion() : generateRelation2x2();

      const ones = countOnes(q.answer);
      const uniq = new Set(q.options.map(cellKey)).size;
      if (ones >= 1 && ones <= 8 && uniq >= 6){
        break;
      }
    }

    state.q = q;
    renderMatrix(q);
    renderOptions(q);
    $debug.textContent = q.debugText;
    setMessage("右下（?）に入る図形を選んでください。");
    hideChara();
    updatePill();
  }

  // ========= Bind =========
  $newBtn.addEventListener("click", newQuestion);
  $showBtn.addEventListener("click", showAnswer);

  // Start
  updatePill();
})();
</script>
</body>
</html>

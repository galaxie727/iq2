<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ガチIQ（MVP）- 自動生成（複数タイプ）</title>
<style>
  :root{
    --bg0:#07090c;
    --bg1:#0b0f14;
    --text:#e9eef6;
    --muted: rgba(233,238,246,0.66);

    /* 枠を“濃く” */
    --stroke-weak: rgba(255,255,255,0.14);
    --stroke-strong: rgba(255,255,255,0.22);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:
      radial-gradient(1200px 600px at 20% 0%, rgba(52,243,160,0.10), transparent 60%),
      radial-gradient(900px 600px at 90% 20%, rgba(52,243,160,0.06), transparent 65%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
    color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }
  .wrap{ max-width: 820px; margin: 0 auto; padding: 18px 14px 26px; }
  .topbar{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; margin-bottom: 12px; }
  h1{ margin:0; font-size: 18px; letter-spacing: .08em; font-weight: 800; }
  .pill{
    padding:8px 10px;
    border:1px solid var(--stroke-strong);
    background: rgba(255,255,255,0.04);
    border-radius: 12px;
    font-size: 12px;
    color: var(--muted);
    white-space:nowrap;
    height: fit-content;
  }

  /* ===== ルール色分け：card枠（濃く） ===== */
  .card{
    --ruleGlow: rgba(52,243,160,0.22);
    --ruleStroke: rgba(52,243,160,0.40);
    border: 2px solid var(--ruleStroke);
    background: rgba(255,255,255,0.045);
    border-radius: 16px;
    padding: 14px;
    box-shadow:
      0 10px 30px rgba(0,0,0,0.38),
      0 0 0 1px var(--ruleGlow) inset,
      0 0 34px var(--ruleGlow);
    backdrop-filter: blur(6px);
  }

  /* XOR寄り = グリーン */
  .rule-xorxor, .rule-xoror, .rule-orxor, .rule-xorand, .rule-andxor, .rule-xorxnor, .rule-xnorxor{
    --ruleGlow: rgba(52,243,160,0.22);
    --ruleStroke: rgba(52,243,160,0.46);
  }
  /* OR/AND混在 = ブルー */
  .rule-orand, .rule-andor, .rule-oror{
    --ruleGlow: rgba(120,170,255,0.22);
    --ruleStroke: rgba(120,170,255,0.48);
  }
  /* AND絡み多め = パープル */
  .rule-andand, .rule-andxnor, .rule-xnorand, .rule-xnorxnor{
    --ruleGlow: rgba(200,120,255,0.22);
    --ruleStroke: rgba(200,120,255,0.50);
  }
  /* NOT絡み = レッド寄り */
  .rule-notnot, .rule-notxor, .rule-xornot, .rule-notor, .rule-ornot, .rule-notand, .rule-andnot, .rule-notxnor, .rule-xnornot{
    --ruleGlow: rgba(255,90,120,0.20);
    --ruleStroke: rgba(255,90,120,0.46);
  }
  /* 2x2 回転 = オレンジ */
  .rule-rot2{
    --ruleGlow: rgba(255,175,90,0.22);
    --ruleStroke: rgba(255,175,90,0.54);
  }
  /* ユニーク6択 = イエロー */
  .rule-unique{
    --ruleGlow: rgba(255,225,90,0.20);
    --ruleStroke: rgba(255,225,90,0.54);
  }

  /* ===== キャラ専用エリア（盤面の外） ===== */
  .charSlot{
    display:none;
    align-items:flex-end;
    justify-content:flex-end;
    gap: 10px;
    margin-bottom: 10px;
  }
  .charImg{
    width: clamp(92px, 24vw, 170px);
    height: auto;
    border-radius: 14px;
    background: rgba(255,255,255,0.08);
    border: 1px solid var(--stroke-strong);
    box-shadow: 0 12px 28px rgba(0,0,0,0.35);
  }
  .bubble{
    max-width: clamp(160px, 46vw, 320px);
    padding: 10px 12px;
    border-radius: 18px;
    background: rgba(0,0,0,0.45);
    border: 1px solid rgba(255,255,255,0.20);
    color: rgba(233,238,246,0.92);
    font-weight: 900;
    letter-spacing: .04em;
    box-shadow: 0 10px 24px rgba(0,0,0,0.35);
    backdrop-filter: blur(6px);
  }

  .matrix{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-top: 6px;
  }
  .cell{
    border:1px solid var(--stroke-weak);
    background: #fff;
    border-radius: 14px;
    overflow:hidden;
    aspect-ratio: 1 / 1;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .cell.q{ position:relative; }
  .qmark{
    position:absolute; inset:0;
    display:flex; align-items:center; justify-content:center;
    font-weight:900; font-size: 34px; color:#111;
    letter-spacing:.05em;
  }

  .msg{
    margin-top: 12px;
    padding: 10px 12px;
    border-radius: 12px;
    border:1px solid var(--stroke-strong);
    background: rgba(255,255,255,0.04);
    color: var(--muted);
    font-size: 13px;
    line-height: 1.45;
    min-height: 42px;
    text-align:center;
  }
  .msg.ok{
    border-color: rgba(52,243,160,0.42);
    background: rgba(52,243,160,0.12);
    color: #d7fff0;
  }
  .msg.ng{
    border-color: rgba(255,77,109,0.42);
    background: rgba(255,77,109,0.12);
    color: #ffe1e1;
  }

  .opts{
    display:grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap:10px;
    width:100%;
    max-width:360px;
    margin:0 auto;
  }
  .opt{
    border: 1px solid var(--stroke-weak);
    background: rgba(255,255,255,0.045);
    border-radius: 14px;
    padding: 8px;
    cursor:pointer;
    transition: transform .06s ease, border-color .12s ease;
    display:flex;
    gap:8px;
    align-items:center;
    justify-content:flex-start;
    min-height: 72px;
  }
  .opt:active{ transform: translateY(1px); }
  .opt:hover{ border-color: rgba(52,243,160,0.35); }

  .badge{
    width: 26px; height: 26px;
    border-radius: 9px;
    display:flex; align-items:center; justify-content:center;
    border: 1px solid rgba(52,243,160,0.40);
    color: rgba(52,243,160,0.95);
    background: rgba(0,0,0,0.18);
    font-weight: 900;
    flex: 0 0 auto;
  }
  .thumb{
    width: 56px; height: 56px;
    border-radius: 12px;
    overflow:hidden;
    border:1px solid rgba(255,255,255,0.18);
    background:#fff;
    flex: 0 0 auto;
    display:flex; align-items:center; justify-content:center;
  }

  .row{
    display:flex; gap:10px; flex-wrap:wrap;
    align-items:center; justify-content:space-between;
    margin-top: 12px;
  }
  .btn{
    border: 1px solid rgba(52,243,160,0.30);
    background: linear-gradient(180deg, rgba(52,243,160,0.20), rgba(52,243,160,0.07));
    color: var(--text);
    padding: 10px 12px;
    border-radius: 12px;
    cursor:pointer;
    font-weight: 800;
    letter-spacing:.04em;
    box-shadow: 0 8px 20px rgba(0,0,0,0.35);
  }
  .btn.secondary{
    border: 1px solid rgba(255,255,255,0.16);
    background: rgba(255,255,255,0.07);
    color: rgba(233,238,246,0.88);
  }

  details{
    margin-top: 12px;
    border:1px solid rgba(255,255,255,0.14);
    border-radius: 12px;
    padding: 10px 12px;
    background: rgba(255,255,255,0.035);
  }
  details > summary{ cursor:pointer; font-weight: 900; color: rgba(233,238,246,0.82); }
  .small{ color: var(--muted); font-size: 12px; line-height: 1.55; margin-top: 8px; white-space: pre-wrap; }

  /* SVG枠が沈まない */
  .matrix svg rect[stroke="#000"]{ stroke: rgba(255,255,255,0.35) !important; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div><h1>ガチIQ（MVP）</h1></div>
      <div class="pill" id="statusPill">出題準備中…</div>
    </div>

    <div class="card" id="card">
      <div class="charSlot" id="charSlot">
        <img class="charImg" id="charImg" src="" alt="">
        <div class="bubble" id="charBubble">……</div>
      </div>

      <div class="matrix" id="matrix"></div>
      <div class="msg" id="msg">「次の問題」を押してスタート。</div>
      <div class="opts" id="opts"></div>

      <div class="row">
        <button class="btn" id="newBtn">次の問題</button>
        <button class="btn secondary" id="showBtn">正解を表示</button>
      </div>

      <details>
        <summary>（開発用）今回の生成ルールを見る</summary>
        <div class="small" id="debug"></div>
      </details>
    </div>
  </div>

<script>
(() => {
  // ========= Utils =========
  const deepEq = (a,b) => a.length===b.length && a.every((v,i)=>v===b[i]);
  const rndInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
  const shuffle = (arr) => {
    const a = arr.slice();
    for (let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  };
  const countOnes = (c) => c.reduce((s,v)=>s+(v?1:0),0);
  const cellKey = (c) => c.join("");

  // ========= Cell ops (3×3 flat 9) =========
  function rot90(c){ return [c[6],c[3],c[0], c[7],c[4],c[1], c[8],c[5],c[2]]; }
  function rot180(c){ return rot90(rot90(c)); }
  function flipH(c){ return [c[2],c[1],c[0], c[5],c[4],c[3], c[8],c[7],c[6]]; }
  function flipV(c){ return [c[6],c[7],c[8], c[3],c[4],c[5], c[0],c[1],c[2]]; }
  function shiftRight(c){ return [c[2],c[0],c[1], c[5],c[3],c[4], c[8],c[6],c[7]]; }
  function shiftDown(c){ return [c[6],c[7],c[8], c[0],c[1],c[2], c[3],c[4],c[5]]; }

  function xor(a,b){ return a.map((v,i)=> (v ^ b[i]) ); }
  function or(a,b){  return a.map((v,i)=> (v | b[i]) ); }
  function and(a,b){ return a.map((v,i)=> (v & b[i]) ); }
  function not(a){   return a.map(v => v ? 0 : 1); }
  function xnor(a,b){ return not(xor(a,b)); }

  function swap2(c){
    const a = c.slice();
    const i = rndInt(0,8);
    let j = rndInt(0,8);
    if (j===i) j = (j+1)%9;
    [a[i],a[j]] = [a[j],a[i]];
    return a;
  }
  function toggleK(c, k=1){
    const a = c.slice();
    const idx = shuffle([...Array(9)].map((_,i)=>i)).slice(0, k);
    idx.forEach(i => a[i] = a[i] ? 0 : 1);
    return a;
  }

  // ほどよい密度のランダム（OR/NOTで増えやすいので控えめ）
  function randCellDense(minOnes=2, maxOnes=4){
    let guard=0;
    while (guard++ < 400){
      const k = rndInt(minOnes, maxOnes);
      const pos = shuffle([...Array(9)].map((_,i)=>i)).slice(0,k);
      const c = Array(9).fill(0);
      pos.forEach(i => c[i]=1);
      return c;
    }
    return Array(9).fill(0);
  }

  // ========= SVG render =========
  function cellToSVG(c, size=140){
    const s = size/3;
    let rects = "";
    for(let i=0;i<9;i++){
      if(c[i]){
        const x = (i%3)*s, y = Math.floor(i/3)*s;
        rects += `<rect x="${x}" y="${y}" width="${s}" height="${s}" fill="#000"/>`;
      }
    }
    const grid =
    `<path d="M ${s} 0 V ${size} M ${2*s} 0 V ${size} M 0 ${s} H ${size} M 0 ${2*s} H ${size}"
      stroke="rgba(255,255,255,0.35)" stroke-width="3" />
     <path d="M ${s} 0 V ${size} M ${2*s} 0 V ${size} M 0 ${s} H ${size} M 0 ${2*s} H ${size}"
      stroke="rgba(0,0,0,0.18)" stroke-width="1" />`;
    return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" aria-hidden="true">
      <rect width="${size}" height="${size}" fill="#fff" stroke="#000" stroke-width="2"/>
      ${rects}${grid}
    </svg>`;
  }

  function buildOptions(answer){
    const candidates = [];
    const add = (c) => {
      const k = cellKey(c);
      if (!candidates.some(x => cellKey(x)===k)) candidates.push(c);
    };

    add(answer);
    add(rot90(answer));
    add(rot180(answer));
    add(flipH(answer));
    add(flipV(answer));
    add(shiftRight(answer));
    add(shiftDown(answer));
    add(xor(answer, rot90(answer)));
    add(toggleK(answer,1));
    add(toggleK(answer,2));
    add(swap2(answer));

    const filtered = candidates.filter(c => {
      const ones = countOnes(c);
      return ones >= 1 && ones <= 8;
    });

    const distractPool = filtered.filter(c => !deepEq(c, answer));
    const distractors = shuffle(distractPool).slice(0, 5);

    let tries = 0;
    while (distractors.length < 5 && tries < 80){
      tries++;
      const variant = toggleK(answer, rndInt(1,2));
      if (!deepEq(variant, answer) && !distractors.some(d => deepEq(d, variant))){
        const ones = countOnes(variant);
        if (ones >= 1 && ones <= 8) distractors.push(variant);
      }
    }

    const options = shuffle([answer, ...distractors]).slice(0,6);
    const ansIndex = options.findIndex(o => deepEq(o, answer));
    return { options, ansIndex };
  }

  // ========= Rule registry =========
  const RULES = [
    { id:"xor",  name:"右 = 左 XOR 中央",  f:(L,M)=>xor(L,M) },
    { id:"or",   name:"右 = 左 OR 中央",   f:(L,M)=>or(L,M)  },
    { id:"and",  name:"右 = 左 AND 中央",  f:(L,M)=>and(L,M) },
    { id:"xnor", name:"右 = 左 XNOR 中央", f:(L,M)=>xnor(L,M)},
    { id:"not",  name:"右 = NOT(左)",      f:(L,M)=>not(L)   }, // 中央は使わない（“逆になる”簡略）
  ];
  const getRule = (id) => RULES.find(r => r.id===id);

  // 行ルール×列ルール（増やしたいならここにセット追加するだけ）
  const RULESETS = [
    { row:"xor",  col:"xor"  },
    { row:"or",   col:"xor"  },
    { row:"xor",  col:"or"   },
    { row:"and",  col:"xor"  },
    { row:"xor",  col:"and"  },
    { row:"or",   col:"and"  },
    { row:"and",  col:"or"   },
    { row:"xnor", col:"xor"  },
    { row:"xor",  col:"xnor" },
    { row:"xnor", col:"xnor" },
    { row:"not",  col:"xor"  },
    { row:"xor",  col:"not"  },
    { row:"not",  col:"not"  },
  ];

  // ========= Generator A: 3x3 row/col ops =========
  function genMatrixRowColOps(){
    const pickSet = RULESETS[Math.floor(Math.random()*RULESETS.length)];
    const rowRule = getRule(pickSet.row);
    const colRule = getRule(pickSet.col);

    function makeSolvedGrid(){
      const a11 = randCellDense(2,4);
      const a12 = randCellDense(2,4);
      const a21 = randCellDense(2,4);
      const a22 = randCellDense(2,4);

      const a13 = rowRule.f(a11, a12);
      const a23 = rowRule.f(a21, a22);

      const a31 = colRule.f(a11, a21);
      const a32 = colRule.f(a12, a22);

      // 右下は「行で計算」でも「列で計算」でも一致する必要がある
      const fromRow = rowRule.f(a31, a32);
      const fromCol = colRule.f(a13, a23);
      if (!deepEq(fromRow, fromCol)) return null;

      const a33 = fromRow;
      return [
        [a11, a12, a13],
        [a21, a22, a23],
        [a31, a32, a33],
      ];
    }

    let grid = null;
    for (let t=0;t<1200;t++){
      const g = makeSolvedGrid();
      if (!g) continue;
      const all = g.flat();
      const onesList = all.map(countOnes);
      const tooExtreme = onesList.some(x => x <= 1 || x >= 8);
      const uniq = new Set(all.map(cellKey)).size;
      if (tooExtreme) continue;
      if (uniq < 7) continue;
      grid = g; break;
    }
    if (!grid){
      // 保険：xor-xor
      const a11 = randCellDense(2,4);
      const a12 = randCellDense(2,4);
      const a21 = randCellDense(2,4);
      const a22 = randCellDense(2,4);
      const a13 = xor(a11,a12);
      const a23 = xor(a21,a22);
      const a31 = xor(a11,a21);
      const a32 = xor(a12,a22);
      const a33 = xor(a31,a32);
      grid = [[a11,a12,a13],[a21,a22,a23],[a31,a32,a33]];
    }

    const answer = grid[2][2];
    const gridWithHole = [
      [grid[0][0], grid[0][1], grid[0][2]],
      [grid[1][0], grid[1][1], grid[1][2]],
      [grid[2][0], grid[2][1], null],
    ];
    const { options, ansIndex } = buildOptions(answer);

    const debugText =
`Type: matrix3x3
RowRule: ${rowRule.name} (${rowRule.id})
ColRule: ${colRule.name} (${colRule.id})
✅ 行と列が別でも両方成立する問題のみ採用`;

    return {
      type:"matrix3x3",
      size:3,
      grid:gridWithHole,
      answer,
      options,
      ansIndex,
      debugText,
      rowRuleId: rowRule.id,
      colRuleId: colRule.id,
    };
  }

  // ========= Generator B: 2x2 rotate =========
  function genRelation2x2Rotate(){
    const A = randCellDense(2,5);
    const B = rot90(A);
    const C = randCellDense(2,5);
    const answer = rot90(C);

    const grid = [[A, B],[C, null]];
    const { options, ansIndex } = buildOptions(answer);
    const debugText =
`Type: relation2x2
Rule: A→B は 90°回転 / C→? も 90°回転`;

    return {
      type:"relation2x2",
      size:2,
      grid,
      answer,
      options,
      ansIndex,
      debugText,
      rowRuleId:"rot2",
      colRuleId:"rot2",
    };
  }

  // ========= Generator C: ユニーク6択（“1個しかない3つ”が全部入った選択肢） =========
  // 3x3の中の「6個の固定位置」を“記号”として使う（見た目が分かりやすい）
  // 6つの記号（= 6つの位置）を、各選択肢は「3記号の組み合わせ」として生成。
  // 条件：3つの記号は1回だけ、残り3つの記号は2回ずつ出る。正解は「1回だけの3つ」を全部含む選択肢。
  function genUniqueOneOff(){
    const basePosPool = shuffle([0,2,3,5,6,8]); // 6個（角+左右中央）
    const symbols = basePosPool.map(p => {
      const c = Array(9).fill(0);
      c[p]=1;
      return c;
    });

    const singlesIdx = shuffle([0,1,2,3,4,5]).slice(0,3);
    const doublesIdx = [0,1,2,3,4,5].filter(i=>!singlesIdx.includes(i));

    const S = singlesIdx;
    const D = doublesIdx;

    const makeCellFromSymbols = (idxs) => {
      let out = Array(9).fill(0);
      idxs.forEach(i => out = or(out, symbols[i]));
      return out;
    };

    // ランダム探索で条件満たす6択を作る
    // 6つの三つ組（各3記号）を作り、出現回数が singles=1、doubles=2 になるようにする
    function tryBuild(){
      // 正解（シングル3つ全部）
      const correctTrip = S.slice(); // 3要素
      // 残り5つを作る（総出現回数: singles 3回 / doubles 6回）
      // 正解で singles を全部1回使ったので、残りでは singles は0回、doubles は6回を満たせばOK。
      // つまり残り5問は「doublesだけで3つ選ぶ」を中心にして、重複しないように組む。
      const remaining = [];

      // doublesの3つから作れる三つ組は1通りだけ（D全部）なので、それだけだと重複する
      // そこで、doublesを2つ + singlesを1つ にしても成立させる。ただし singles はもう“1回だけ”条件が壊れるのでダメ。
      // → なので「記号」方式は“厳密条件”を満たすには組み合わせ探索が必要。
      // ここでは「記号」ではなく「記号“セット”」を作って counts を満たす三つ組の集合を探索する。

      // 探索：6個の記号の出現回数ターゲットを作る
      // targetCount[i] = (iがsingleなら1 else 2)
      const targetCount = Array(6).fill(0);
      S.forEach(i => targetCount[i]=1);
      D.forEach(i => targetCount[i]=2);

      // 6つの三つ組をランダム生成して、ターゲット一致&正解が一意になるまで探す
      const allTriplets = [];
      allTriplets.push(correctTrip.slice().sort((a,b)=>a-b));

      let guard=0;
      while (guard++ < 5000){
        // 残り5つをランダムに作る
        allTriplets.length = 1;

        while (allTriplets.length < 6){
          const trip = shuffle([0,1,2,3,4,5]).slice(0,3).sort((a,b)=>a-b);
          // 重複禁止
          if (allTriplets.some(t => t.join(",")===trip.join(","))) continue;
          allTriplets.push(trip);
        }

        // カウント計算
        const cnt = Array(6).fill(0);
        allTriplets.forEach(tri => tri.forEach(i => cnt[i]++));
        if (!deepEq(cnt, targetCount)) continue;

        // 正解条件：「single3つ全部含む」三つ組が1つだけ
        const isCorrect = (tri) => S.every(i=>tri.includes(i));
        const correctOnes = allTriplets.filter(isCorrect);
        if (correctOnes.length !== 1) continue;

        // それが最初に入れた correctTrip と一致してること
        if (correctOnes[0].join(",") !== correctTrip.slice().sort((a,b)=>a-b).join(",")) continue;

        return allTriplets;
      }
      return null;
    }

    const triplets = tryBuild() || [
      // 最悪の保険（成立してない可能性があるので debug に出す）
      S.slice().sort((a,b)=>a-b),
      shuffle([0,1,2]).sort((a,b)=>a-b),
      shuffle([3,4,5]).sort((a,b)=>a-b),
      shuffle([0,3,4]).sort((a,b)=>a-b),
      shuffle([1,4,5]).sort((a,b)=>a-b),
      shuffle([2,3,5]).sort((a,b)=>a-b),
    ];

    const correctTripSorted = S.slice().sort((a,b)=>a-b).join(",");
    const optionsCells = triplets.map(tri => makeCellFromSymbols(tri));
    const ansIndex = triplets.findIndex(tri => tri.join(",")===correctTripSorted);
    const answer = optionsCells[ansIndex];

    // 盤面は「?」だけにして、選択肢で解くタイプにする（見やすい）
    const grid = [[null]];

    const debugText =
`Type: unique6
Rule: 同じ記号が2つずつ + 1個しかない記号が3つ → その3つ全部を含む選択肢が正解
Singles(symbol index): ${S.join(",")}
Doubles(symbol index): ${D.join(",")}
ansIndex: ${ansIndex}`;

    return {
      type:"unique6",
      size:1,
      grid,
      answer,
      options: optionsCells,
      ansIndex,
      debugText,
      rowRuleId:"unique",
      colRuleId:"unique",
      promptText:"6つの選択肢の中で『1回しか出てこない記号』が3つある。それが全部入ってる選択肢を選べ。",
    };
  }

  // ========= Generators =========
  const GENERATORS = [
    { w: 65, fn: genMatrixRowColOps },
    { w: 20, fn: genRelation2x2Rotate },
    { w: 15, fn: genUniqueOneOff },
  ];
  function pickGenerator(){
    const sum = GENERATORS.reduce((s,x)=>s+x.w,0);
    let r = Math.random()*sum;
    for (const g of GENERATORS){
      r -= g.w;
      if (r <= 0) return g.fn;
    }
    return GENERATORS[0].fn;
  }

  // ========= UI =========
  const $matrix = document.getElementById("matrix");
  const $card = document.getElementById("card");
  const $opts = document.getElementById("opts");
  const $msg = document.getElementById("msg");
  const $debug = document.getElementById("debug");
  const $pill = document.getElementById("statusPill");
  const $newBtn = document.getElementById("newBtn");
  const $showBtn = document.getElementById("showBtn");

  const $charSlot = document.getElementById("charSlot");
  const $charImg = document.getElementById("charImg");
  const $charBubble = document.getElementById("charBubble");

  const IMG = {
    dekabusa: "chara/dekabusa.png",
    chi: "chara/chi.png"
  };

  const LABELS = ["A","B","C","D","E","F"];
  let state = { q:null, locked:false, revealed:false };

  function setMessage(text, kind=""){
    $msg.classList.remove("ok","ng");
    if (kind) $msg.classList.add(kind);
    $msg.textContent = text;
  }

  function setChar(kind=null, text="……"){
    if (!kind){
      $charSlot.style.display = "none";
      return;
    }
    $charImg.src = IMG[kind];
    $charImg.alt = kind;
    $charBubble.textContent = text;
    $charSlot.style.display = "flex";
  }

  function updatePill(){
    if (!state.q){ $pill.textContent = "未開始"; return; }
    $pill.textContent = state.locked ? "回答済み" : "回答待ち";
  }

  function applyRuleColor(q){
    if (!$card || !q) return;
    // rule- を全部剥がす
    [...$card.classList].forEach(c => { if (c.startsWith("rule-")) $card.classList.remove(c); });

    if (q.type === "relation2x2"){
      $card.classList.add("rule-rot2");
      return;
    }
    if (q.type === "unique6"){
      $card.classList.add("rule-unique");
      return;
    }
    // matrix3x3
    const row = q.rowRuleId || "xor";
    const col = q.colRuleId || "xor";
    $card.classList.add(`rule-${row}${col}`);
  }

  function renderMatrix(q){
    const n = q.size || 3;
    $matrix.innerHTML = "";
    $matrix.style.gridTemplateColumns = `repeat(${n}, 1fr)`;

    // unique6 は盤面を「?」だけにする
    if (q.type === "unique6"){
      const cell = document.createElement("div");
      cell.className = "cell q";
      const mark = document.createElement("div");
      mark.className = "qmark";
      mark.textContent = "?";
      cell.appendChild(mark);
      $matrix.appendChild(cell);
      return;
    }

    const holeIndex = n*n - 1;
    for (let i=0;i<n*n;i++){
      const cell = document.createElement("div");
      cell.className = "cell" + (i===holeIndex ? " q" : "");
      if (i===holeIndex){
        const mark = document.createElement("div");
        mark.className = "qmark";
        mark.textContent = "?";
        cell.appendChild(mark);
      } else {
        const r = Math.floor(i/n);
        const c = i % n;
        cell.innerHTML = cellToSVG(q.grid[r][c], 140);
      }
      $matrix.appendChild(cell);
    }
  }

  function renderOptions(q){
    $opts.innerHTML = "";
    q.options.forEach((optCell, idx) => {
      const btn = document.createElement("button");
      btn.className = "opt";
      btn.type = "button";
      btn.addEventListener("click", () => onPick(idx));

      const badge = document.createElement("div");
      badge.className = "badge";
      badge.textContent = LABELS[idx];

      const thumb = document.createElement("div");
      thumb.className = "thumb";
      thumb.innerHTML = cellToSVG(optCell, 64);

      btn.appendChild(badge);
      btn.appendChild(thumb);
      $opts.appendChild(btn);
    });
  }

  function onPick(idx){
    if (!state.q || state.locked) return;
    state.locked = true;
    state.revealed = false;
    updatePill();

    const correct = (idx === state.q.ansIndex);
    if (correct){
      setMessage(`正解：${LABELS[idx]} ✅`, "ok");
      setChar("chi", "ギュウ。");
    } else {
      setMessage(`不正解：${LABELS[idx]} ❌（正解はまだ隠しています）`, "ng");
      setChar("dekabusa", "……");
    }
  }

  function showAnswer(){
    if (!state.q) return;
    state.revealed = true;
    const ansLabel = LABELS[state.q.ansIndex];
    setMessage(`正解は ${ansLabel} です。`, "ok");

    // unique6 は盤面に正解を表示
    if (state.q.type === "unique6"){
      const cell = $matrix.querySelector(".cell");
      cell.innerHTML = cellToSVG(state.q.answer, 140);
      return;
    }

    const qCells = Array.from($matrix.querySelectorAll(".cell"));
    const last = qCells[qCells.length - 1];
    last.innerHTML = cellToSVG(state.q.answer, 140);
  }

  function newQuestion(){
    state.locked = false;
    state.revealed = false;
    setChar(null);

    // 生成（失敗したらリトライ）
    let q = null;
    for (let t=0;t<60;t++){
      q = pickGenerator()();
      const uniq = new Set(q.options.map(cellKey)).size;
      const ones = countOnes(q.answer);
      if (uniq >= 6 && ones >= 1 && ones <= 8) break;
    }

    state.q = q;
    applyRuleColor(q);
    renderMatrix(q);
    renderOptions(q);

    $debug.textContent = q.debugText;

    if (q.type === "unique6"){
      setMessage(q.promptText || "選択肢から正解を選んでください。");
    } else {
      setMessage("右下（?）に入る図形を選んでください。");
    }

    updatePill();
  }

  $newBtn.addEventListener("click", newQuestion);
  $showBtn.addEventListener("click", showAnswer);
  updatePill();
})();
</script>
</body>
</html>
